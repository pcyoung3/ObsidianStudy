---
Index:
  - "[[2. PS&AlgorithmIndex]]"
tags:
  - Study
  - PS
---

> [!note] Hash는 Hash 함수를 이용해서 Bucket을 미리 만들어놓고 1대1 매칭을 시키는 알고리즘이다
> 탐색시간이 $O(1)$ 입력시간도 $O(1)$이기 때문에 탐색을 자주해야할 때 사용하면 좋다

## 1. 기본개념
---
Key값을 Hash 함수를 이용해서 Hash로 변경하여 그 값을 Bucket에 저장한다
따라서 탐색시간 및 입력시간이 $O(1)$인 장점을 가지고 있다
하지만 Bucket공간이 필요하므로 시간복잡도를 위해서 공간복잡도를 사용한 알고리즘

탐색시간이  $O(1)$이므로 많은 탐색이 발생하는 곳에 사용하면 좋다
DataBase에서도 Indexing을 이용해서 빠른 탐색을 할 수 있는데
해당 개념을 사용하는 것이다
   
   
## 2. 해시충돌(Hash Collision)
---
해시함수에 많은 Key값을 계속 집어넣으면 Key와 Hash의 쌍이 1대1이었다가 
Bucket 공간의 한계 또는 Hash 함수의 한계 등의 이유로 1대1을 유지하지 못하는 상황

이런 경우를 해시 충돌이라고 하고 Hash는 해당 부분을 해결해야 한다.

해시충돌을 해결하는 방법은 주로 2가지가 있다
   
### 2-1. 체이닝(Chaining)
Hash Table 즉, Bucket에 중복된 Hash값이 들어올 경우
같은 공간에 List를 생성하고 List에 추가하는 식으로 커버하는 방식 가장 많이 사용되는 방식이다
하지만 이 방법도 데이터가 계속 쌓이게 되면 List의 원래 검색 복잡도인 $O(n)$의 복잡도가 됨

## 2-2. Open Addressing
해시충돌이 발생하면 비어있는 Bucket공간에 Hash를 저장하는 방식
체이닝과 다르게 list 처럼 추가로 자료구조가 들어가진 않아서 공간복잡도는 더 적다
하지만 Hash가 비어있는 공간을 계속 찾아야 하므로 시간복잡도의 문제가 생김
특히, 비어있는 공간이 Bucket 내부의 특정 부분에만 집중되는 Clustering 현상이 발생할 수 있다.
   
   
## 3. 해시충돌 시 C++ STL의 처리
---
C++ STL에서는 해시충돌이 발생했을 때 위의 기법들 중
체이닝 기법을 이용해서 해시충돌을 해결한다.
이 때 Data양이 임계점을 넘었을 경우 추가적으로 Bucket의 크기를 동적으로 할당한다
이런식으로 해서 체인의 평균길이를 짧게 유지한다
