---
Index:
  - "[[PS&AlgorithmIndex]]"
tags:
  - Study
  - PS
Algorithm_type:
  - greedy
---
## 문제
https://www.acmicpc.net/problem/11501
홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다.

1. 주식 하나를 산다.
2. 원하는 만큼 가지고 있는 주식을 판다.
3. 아무것도 안한다.

홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.

예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.

## 입력

입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.

## 출력

각 테스트케이스 별로 최대 이익을 나타내는 정수 하나를 출력한다. 답은 부호있는 64bit 정수형으로 표현 가능하다.

## 예제 입력 1 복사

```
3
3
10 7 6
3
3 5 9
5
1 1 3 1 2
```

## 예제 출력 1 복사

```
0
10
5
```
   
---
## 풀이
> [!note] 그리디 문제
> 주식이 상향할 때만 이득이 생기기 때문에 현재 나온 값보다 뒤에 나온 값이 커야 되지만
> 결국 생각해보면 가장 큰 최댓값 이전에 나오는 값들을 더한 것이 정답이다.
> 문제는 뒤에 나오는 최댓값이 언제 나올지 모르고 그리고 최댓값이 나온다 해도 $O(n^2)$의 시간복잡도를 가진다
> 
> 이 부분을 index를 뒤부터 진행시키는 방식으로 진행시키는 것으로 해결
```cpp
#include <bits/stdc++.h>
using namespace std;

int arr[1000000];

int main()
{
	int t;
	cin >> t;

	while (t--)
	{
		int n;
		cin >> n;

		for (int i = 0; i < n; i++)
			cin >> arr[i];

		/*
		* 그리디 풀이 : 증가한다면 최대값이 나오기 전까지 계속 누적하면 됨
		* 앞에서부터 진행한다면 최대값이 언제 오는지 모르기때문에 n^2으로 접근해야 함
		* 따라서 뒤에서부터 진행한다
		*/
		int mx = -1;
		long ans = 0;
		for (int i = n - 1; i >= 0; i--)
		{
			if (mx < arr[i])
			{
				mx = arr[i];
				continue;
			}
			else
				ans = ans + (mx - arr[i]);
		}

		cout << ans << "\n";
	}
}
```