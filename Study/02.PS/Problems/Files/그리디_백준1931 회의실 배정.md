---
Index:
  - "[[2. PS&AlgorithmIndex]]"
  - "[[바킹독_16_Greedy]]"
tags:
  - Study
  - PS
Algorithm_type:
  - greedy
---
## 문제
https://www.acmicpc.net/problem/1931
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

## 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

## 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

## 예제 입력 1 복사

```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

## 예제 출력 1 복사

```
4
```

## 힌트

(1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.

   
---
## 풀이
> [!note] 전위순회나 DP를 사용해서 풀 수는 있지만 시간복잡도가 충분하지 않다
>    
> 
> | Brute Force 또는 DP로 진행했을 때 시간복잡도 |
> | :--- |
> | ![[1931_a_01.png]] |
> | **그리드를 사용 : 명제 정하기**<br>직관적으로 봤을 때는 현재 회의가 끝난 시간이 t라고 할 때 t 이후의 시작시간을 가진 회의 중에서 가장 먼저 끝나는 회의를 택하는 것이 최적이라는 것을 알 수 있다. 하지만 귀류법으로 증명해서 좀 더 그리드임을 확실하게 할 수 있다. |
> | ![[1931_a_02.png]] |
> | **귀류법으로 증명 : 회의 A, 회의 B가 있다고 가정**<br>만약 t이후 가장 먼저 끝나는 회의가 최적해가 아니라면 회의 A대신 회의 B를 선택하는 것이 더 이득일 수 있다는 말이다. 하지만 회의 B를 선택할 경우 뒤에 회의를 더 많이 잡을 수 있지도 않고 회의 B전에 있던 시간을 활용할 수도 없다. 따라서 회의 B를 선택하는 것은 최적해가 아니라는 모순을 찾을 수 있다 |
> | ![[1931_a_03.png]] |

> [!tip] pair의 정렬
> pair자료형을 sort로 정렬할 때 first를 기준으로 정렬하고 first가 같다면 second 기준으로 정렬된다
> 
> 따라서 여기서는 회의가 끝난 시점을 first로 두고 second를 시작시점으로 두어서
> 우선적으로 회의가 끝난 기준으로 정렬하고 빨리 회의가 끝난 것 중 가장 먼저 시작하는 회의를 기준으로 또 정렬한 것

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
pair<int, int> s[100005]; // schedule, 정렬의 편의를 위해 {끝 시간, 시작 시간}으로 저장

int main(void) 
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> s[i].second >> s[i].first;

	sort(s, s + n); // 먼저 끝나는 시간을 비교하고, 끝나는 시간이 동일하면 시작 시간 순으로 정렬

	int ans = 0;
	int t = 0; // 현재 시간
	for (int i = 0; i < n; i++) 
	{
		if (t > s[i].second) 
			continue; // 시작 시간이 현재 시간보다 이전인 회의라면 무시
		ans++; // 시작 시간이 현재 시간 이후인 회의를 찾았으므로 회의의 수에 1 증가
		t = s[i].first; // 현재 시간을 s[i]의 끝나는 시간으로 변경한다.
	}

	cout << ans;
}
```