---
Index:
  - "[[PS&AlgorithmIndex]]"
  - "[[바킹독_16_Greedy]]"
tags:
  - Study
  - PS
Algorithm_type:
  - greedy
---
## 문제
준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

## 출력

첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

## 예제 입력 1 복사

```
10 4200
1
5
10
50
100
500
1000
5000
10000
50000
```

## 예제 출력 1 복사

```
6
```

## 예제 입력 2 복사

```
10 4790
1
5
10
50
100
500
1000
5000
10000
50000
```

## 예제 출력 2 복사

```
12
```
   
---
## 풀이
> [!note] DP로 접근할 수 있지만 시간복잡도가 초과된다!
> [[DP_백준9084 동전]], [[DP_백준2293 동전 1]] 과 같은 유형의 문제이지만
> DP로 접근하면 시간초과가 발생한다.
> ![[Pasted image 20240113101825.png]]
> 참고로 DP의 점화식은 다음과 같다.
> 문제의 조건이 K가 최대 1억, N이 최대 10이어서 $O(NK)$를 할 경우 시간초과 발생
> 따라서 DP가 아닌 그리디로 접근해야 한다

> [!success] 그리디로 풀어보자
> 코딩테스트라면 수학적으로 꼭 증명을 하지 않고 대충 넘겨짚어야 하지만
> 직관적으로 맞는 것 같다와 수학적으로 올바르다는 큰 차이가 있다.
> 하지만 그리디를 시작하고 있기 때문에 증명과정을 한번 보는 것도 나쁘지는 않음.
>    
> 문제의 포인트는 가장 큰 동전을 많이 쓸 수록 동전을 최소로 사용할 수 있다는 것이다.
> 해당 명제를 증명하기 위해서
> 10, 50, 100, 500원 동전이 있다고 하자
> 직관적으로 봤을 때는 500원을 많이 사용할 수록 동전 개수가 적어질 것이라는 것으로 보이지만
> 수학적으로 증명했을때도 과연 같을지 보도록 하자
>    
> #### 귀류법으로 증명
> 	귀류법이란?) 명제의 결론을 부정하여 부정한 결론이 모순임을 밝혀내어 명제가 참임을 증명하는 방법
>    
> #### 보조정리1
> 동전을 최소로 소모하면서 물건값을 지불하려면 10/100원 동전은 4개이하, 50원 동전은 1개 이하로 사용해야 함
>    
> #### 귀류법 가정
> 10/100원 동전을 5개 이상, 50원 동전을 2개 이상 사용하는 것이 동전의 개수를 최소로 줄일 수 있다
> But!
> 10/100원 동전을 5개 이상 사용 -> 50/500원 동전으로 대체
> 50원 동전을 2개 이상 사용 -> 100원 동전으로 대체
> 대체가 된 동전은 1개인데 반해 5개, 2개씩 더해지므로 맞지 않는다.
>    
> #### 증명
> 10/100원 동전을 5개 이상 혹은 50원 동전을 2개 이상 사용하면 동전을 최소로 소모할 수 없다
> -> 10/100원 동전은 4개이하, 50원 동전은 1개 이하로 사용하는 명제가 참이다
>    
> #### 명제
> 동전을 최소로 소모하면서 물건값을 지불하려면 500원 동전을 최대한 많이 써야 한다.
>    
> #### 증명
> 10, 50, 100원 동전으로는 $10\times10+50\times1+100\times4=490$원까지만 감당 가능,
> 500원을 다 사용하지 않을 경우 10, 50, 100원으로 500원 이상을 감당해야 함

> [!bug] 사실 이 증명법은 반례가 있다.
> 문제에서 조건이 동전의 종류가 배수로 나와서 성리한 명제
> 만약 동전의 종류가 배수로 나오지 않는다면 명제는 성립하지 않게된다
>    
> #### 반례
> 동전의 종류가 1, 9, 10원이라고 해보자
> 18원을 만드는 방법으로 최소 동전개수는?
> 
> 이상적인 답은 9원을 2개 써서 18원을 만드는 것이 답이다.
> 하지만 위처럼 그리디 방식을 썼을 경우 10원부터 쓰기 때문에 
> 10원 1개, 1원 8개를 써서 총 9개의 동전을 사용한다.
> 
> 이처럼 문제가 비슷해보인다고 섣부르게 그리디로 접근하면 낭패를 볼 가능성이 높기때문에
> 그리디는 항상 주의해서 접근해야 한다

```cpp
#include <bits/stdc++.h>
#include <bitset>
using namespace std;

int arr[12];

int main(void) 
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n, k;
	cin >> n >> k;
	for (int i = 0; i < n; i++)
		cin >> arr[i];

	int ans = 0;
	//그리디 : 가장 큰 동전을 많이 사용하는 것이 최소 동전 개수
	for (int i = n - 1; i >= 0; i--)	//오름차순으로 입력되므로 가장 마지막부터 순회
	{
		ans += k / arr[i];	//동전이 k보다 크다면 나눴을 경우 0이 나와서 +를 해도 변경 안됨
		k %= arr[i];	//k값을 나머지로 하여 점차적으로 계산
	}

	cout << ans;
}
```