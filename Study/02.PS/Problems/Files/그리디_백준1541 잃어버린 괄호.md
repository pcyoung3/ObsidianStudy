---
Index:
  - "[[2. PS&AlgorithmIndex]]"
tags:
  - Study
  - PS
Algorithm_type:
  - greedy
---
## 문제
https://www.acmicpc.net/problem/1541
세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.

그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.

괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.

## 입력

첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.

## 출력

첫째 줄에 정답을 출력한다.

## 예제 입력 1 복사

```
55-50+40
```

## 예제 출력 1 복사

```
-35
```

## 예제 입력 2 복사

```
10+20+30+40
```

## 예제 출력 2 복사

```
100
```

## 예제 입력 3 복사

```
00009-00009
```

## 예제 출력 3 복사

```
0
```
   
---
## 풀이
> [!info] 그리디 문제
> $-$ 부호가 나오면 괄호를 열고 다음 $-$부호가 올 때 괄호를 닫으면 그게 최솟값이다
> 그 이유는 $-$부호 뒤의 숫자를 가장 크게 만드는 것이 최솟값이기 때문 -> 큰 숫자를 뺄수록 최솟값
> 
> 따라서 $-$값 이후의 숫자를 누적해서 다음 $-$부호가 나오는 순간 뺄셈을 수행하고
> 그 이외의 경우에는 값을 누적하고 마지막 처리를 하면 됨

> [!tip] 문자열 숫자 변환
> 숫자와 연산자가 전부 문자열로 들어와서 문자열변환에 어려움이 있다
> 임시 string 객체를 만들고 atoi 함수로 int로의 변환을 실행
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	string s;
	cin >> s;

	string str = "";		//입력값을 받기 위한 변수
	int ans = 0;			//최종 값
	int temp = 0;			//뺄셈연산을 위한 중간저장 값
	bool isSub = false;		//뺄셈 연산이 들어왔는지 체크
	for (int i = 0; i < s.length(); i++)
	{
		if (s[i] != '+' && s[i] != '-')	//숫자일 경우 읽어서 입력값을 받음
			str += s[i];
		else
		{
			int curNum = stoi(str);	//0009 같은 문자열을 int형 9로 변환
			temp += curNum;			//+연산 -연산 공통으로 temp값에 값을 누적
			if (s[i] == '-')		//-연산이 들어왔을 경우
			{
				if (!isSub)	//- 연산이 처음일 경우
				{
					ans += temp;	//이전 연산은 전부 +였으므로 ans에 값을 누적
					isSub = true;
					temp = 0;		//temp값 초기화
				}
				else		//이전에 -연산이 이미 들어왔을 경우
				{
					ans -= temp;	//지금까지 누적해온 temp값을 뺀다
					temp = 0;		//temp값 초기화
				}
			}

			str = "";
		}
	}

	//마지막 str 처리 -> 기본적으로 위에서 하는 연산과 같음
	int curNum = stoi(str);
	temp += curNum;
	if (isSub)
		ans -= temp;
	else
		ans += temp;
	
	cout << ans;
}
```
   
   
## 다른풀이
> [!success] 더 최적의 그리디 풀이방법
> 사실 좀 더 살펴보면 $-$부호가 나온 이후로 그 뒤의 숫자들은 전부 뺄 수 있다.
> $+$연산은 더 큰 숫자를 뺄 때 누적시키는데 사용하고 $-$연산도 어짜피 뺄셈이기 때문에
> 결론적으로는 $-$이후의 숫자들은 전부 뺄셈이라고 봐도 됨
```cpp
#include <bits/stdc++.h>
using namespace std;

int tmp, ans;
int sign = 1;

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	string input;
	cin >> input;
	for (char c : input)
	{
		if (c == '+' || c == '-')	//부호일 때
		{
			ans += tmp * sign;

			if (c == '-')	//1번이라도 -가 나왔으면 그 이후부터는 전부 뺀다
				sign = -1;	//sign은 1 또는 -1로서 부호를 결정

			tmp = 0;	//임시값 초기화
		}
		else	//숫자일 때
		{
			tmp *= 10;	//문자열을 1자리씩 읽으므로 전 숫자에 10을 곱해서 자리수를 누적
			tmp += c - '0';
			//전 숫자가 2가 들어왔고 이번숫자가 5라면 2 * 10 + ('5' - '0') = 25를 누적
		}
	}
	ans += tmp * sign;	//마지막 숫자처리

	cout << ans;
}
```