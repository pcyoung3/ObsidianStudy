---
Index:
  - "[[6. ConfidentialIndex]]"
tags:
  - Study
  - Confidential
---
   
## 1. 1번문제
---
![[KakaoTalk_20240306_132204999.jpg]]
![[KakaoTalk_20240306_132204999_01.jpg]]
![[KakaoTalk_20240306_132204999_02.jpg]]
![[KakaoTalk_20240306_132204999_03.jpg]]

## 풀이
```cpp
#include <bits/stdc++.h>
#include <unordered_set>
using namespace std;

vector<string> solution(vector<string> teamIDs, vector<string> additional)
{
	vector<string> ans;

	unordered_set<string> FindID;
	
	for (auto id : teamIDs)
		FindID.emplace(id);

	for (auto str : additional)
	{
		if (FindID.find(str) == FindID.end())
		{
			FindID.emplace(str);
			ans.push_back(str);
		}
	}

	return ans;
}

int main()
{
	vector<string> teamIDs = { "world", "prog" };
	vector<string> additional = { "hello", "world", "code", "hello", "try", "code" };

	vector<string> ans = solution(teamIDs, additional);

	for (auto str : ans)
		cout << str << "\n";
}
```
   
   
## 2. 2번문제
---
![[KakaoTalk_20240306_132231123.jpg]]
![[KakaoTalk_20240306_132231123_01.jpg]]
![[KakaoTalk_20240306_132231123_02.jpg]]
![[KakaoTalk_20240306_132231123_03.jpg]]

## 풀이
```cpp
#include <bits/stdc++.h>
#include <unordered_set>
using namespace std;

bool solution(string s, string cipher)
{
	bool answer = true;

	int origin[26] = {};
	int password[26] = {};

	int originLength = s.length();

	for (int i = 0; i < originLength; i++)
	{
		origin[s[i] - 'a']++;
		password[cipher[i] - 'a']++;

		if (origin[s[i] - 'a'] != password[cipher[i] - 'a'])
		{
			answer = false;
			break;
		}
	}
	return answer;
}

int main()
{
	bool ans = solution("hello", "bbvmu");
	cout << ans;
}
```
   
   
## 3. 3번문제
---
![[KakaoTalk_20240306_132256037.jpg]]
![[KakaoTalk_20240306_132256037_01.jpg]]
![[KakaoTalk_20240306_132256037_02.jpg]]
![[KakaoTalk_20240306_132256037_03.jpg]]
![[KakaoTalk_20240306_132256037_04.jpg]]
![[KakaoTalk_20240306_132256037_05.jpg]]
![[KakaoTalk_20240306_132256037_06.jpg]]

## 틀린풀이
```cpp
#include <bits/stdc++.h>
#include <unordered_set>
using namespace std;

#define X first
#define Y second

int d[100000];

int solution(int N, vector<vector<int>> relation, vector<string> dirname)
{
	int answer = 0;

	vector<pair<int, int>> rel;
	for (int i = 0; i < relation.size(); i++)
		rel.push_back({ relation[i][0], relation[i][1] });
	sort(rel.begin(), rel.end());

	d[0] = dirname[rel[0].X - 1].length();
	d[rel[0].Y - 1] = d[0] + dirname[rel[0].Y - 1].length() + 1;

	int relSize = rel.size();
	for (int i = 1; i < relSize; i++)
		d[rel[i].Y - 1] = d[rel[i].X - 1] + dirname[rel[i].Y - 1].length() + 1;

	answer = *max_element(d, d + 100000);
	return answer;
}

int main()
{
	int n = 7;
	vector<vector<int>> relation =
	{
		{3, 7},
		{1, 2},
		{2, 5},
		{1, 4},
		{2, 6},
		{1, 3},
	};
	vector<string> dirname = { "root", "abcd", "cs", "hello", "etc", "hello", "solution" };
	int ans = solution(n, relation, dirname);
	cout << ans;
}
```