---
Index:
  - "[[6. ConfidentialIndex]]"
tags:
  - Study
  - Confidential
---
   
## 1번문제
---
![[스크린샷 2024-01-14 140939.png]]
```
문자열 배열을 돌면서 각 알파벳을
temp 배열에 집어넣음

temp배열을 순회하면서 홀수가 몇개인지 카운팅함
```
   
   
## 2번문제
---

| ![[스크린샷 2024-01-14 141016.png]] |
| ---- |
| ![[스크린샷 2024-01-14 141023.png]] |
```cpp
class BuffManager
{
public:
	const int NONE = 0;
	const int DEFAULT_TIME = 60;

	void ApplyBuff(int buffId)
	{
		if (mBuffId == buffId)
		{
			// 1. 같은 종류의 버프를 적용하려 할 때 : 지속시간을 60초로 초기화
			mBuffTime = DEFAULT_TIME;
		}
		else
		{
			// 2. 다른 종류의 버프를 적용하려 할때 : 버프큐에 enqueue
			mBuffQueue.push(buffId);
			if (mBuffId == NONE)
			{
				ApplyNextBuff();
			}
		}
	}

	void ExpireBuff()
	{
		if (mBuffTime > 0)
		{
			// 버프 지속시간이 아직 남아있음
			mBuffTime--;
		}
		else
		{
			// 버프 지속시간이 종료되었을 때
			// 2. 버프큐가 비어 있지 않은 경우 : 버프 적용
			if (!mBuffQueue.empty())
			{
				ApplyNextBuff();
			}
			else
			{
				//1. 버프 큐가 비었을 경우 : 버프 정보 초기화
				mBuffId = NONE;
				mBuffTime = NONE;
			}
		}
	}
public:
	void GameLoop()
	{
		while (true)
		{

			// 버프 관리 (1초에 한 번 호출)
			ExpireBuff();
			// 1초에 한 번 호출되도록 대기
			std::this_thread::sleep_for(std::chrono::seconds(1));
		}
	}

private:
	int mBuffId = NONE; // 버프 종류
	int mBuffTime = NONE; // 버프 남은 지속 시간
	queue<int> mBuffQueue; // 버프 큐

	int GetBuffQueueFront()
	{
		if (mBuffQueue.empty())
			return NONE;

		return mBuffQueue.front();
	}

	void ApplyNextBuff()
	{
		mBuffId = mBuffQueue.front();
		mBuffTime = DEFAULT_TIME;
		mBuffQueue.pop();

		// 동일한 버프가 연속으로 존재할 경우, 한번만 적용하고 나머지는 제거
		while (!mBuffQueue.empty() && mBuffQueue.front() == mBuffId)
		{
			mBuffQueue.pop();
		}
	}


	int main()
	{
		BuffManager buffManager;

		// 매 프레임마다 호출
		buffManager.GameLoop();
		// 버프 적용 예시
		buffManager.ApplyBuff(1);

		return 0;
	}
};
```
   
   
## 3번문제
---
![[스크린샷 2024-01-14 141033.png]]
```
string으로 변환한 뒤에 
배열 순회하면서 숫자 5를 찾음
5를 삭제한 값을 temp배열에 넣음

string 배열 순회 후
temp의 max_elements 찾음
```
   
   
## 4번문제
---

| ![[스크린샷 2024-01-14 141051.png]] |
| ---- |
| ![[스크린샷 2024-01-14 141059.png]] |
```
1)
dbid와 guildlevel은 음수일 수 없으므로 
unsigned를 붙이는 게 좋을 것 같습니다.

GetGuildLevel에서 해당 방식으로 찾게 되면
원소가 없을 경우 새로 생성하게 됩니다.
즉, 찾기에 실패할 경우 실패한 id로 map에 원소가 새로 생기게 되므로
해당 방식을 변경해야 합니다.
find함수를 이용해야 합니다.

AddGuild 함수에서 해당 방식으로 원소를 입력하게 되면 
위에서 말씀드린대로 원소가 있으면 덮어씌워지고 원소가 없으면 새로 만들어지는 방식입니다.
따라서 외부에서 입력할 때 id를 실수로 같은 DB ID를 호출할 경우 
GuildLevel이 덮어씌워질 수 있는 위험성이 있습니다.
결론적으로 입력하기 전 해당 Guild ID 가 있는지부터 확인을 해야 합니다.(SetGuildLevel함수처럼)
auto found = guildLevelMap.find(guildDbId);
를 먼저 수행해서 원소의 유무를 확인하고 그에 따른 처리를 해야합니다.

2)
map에 2개 이상의 쓰레드가 동시 접근하면
non-Thread safe 하므로
1. std::atomic을 사용해서 guildDbId와 guildLevel을 선언
2. critical section으로 Set, Add 함수에서 lock을 걸고 값을 변경해야 합니다.
```
   
   
## 5번문제
---
![[스크린샷 2024-01-14 141104.png]]
```cpp
void MergeWithSort(int* A, int sizeA, const int* B, int sizeB)
{
   int i = sizeA - 1;
   int j = sizeB - 1;
   int mergedIndex = sizeA + sizeB - 1;

   while (i >= 0 && j >= 0)
   {
      if (A[i] > B[j])
      {
         A[mergedIndex] = A[i];
         i--;
      }
      else
      {
         A[mergedIndex] = B[j];
         j--;
      }
      mergedIndex--;
   }

   while (j >= 0)
   {
      A[mergedIndex] = B[j];
      j--;
      mergedIndex--;
   }
}

int main()
{
   const int sizeA = 5;
   const int sizeB = 3;
   int A[sizeA + sizeB] = { 2, 3, 5, 7, 9 }; // 정렬된 배열 A
   int B[sizeB] = {1, 4, 6 }; // 정렬된 배열 B

   std::cout << "Array A before merge: ";
   for (int i = 0; i < sizeA; ++i)
      std::cout << A[i] << " ";
   std::cout << std::endl;

   std::cout << "Array B before merge: ";
   for (int i = 0; i < sizeB; ++i)
      std::cout << B[i] << " ";
   std::cout << std::endl;

   MergeWithSort(A, sizeA, B, sizeB);

   std::cout << "Merged Array A after merge: ";
   for (int i = 0; i < sizeA + sizeB; ++i)
      std::cout << A[i] << " ";
   std::cout << std::endl;

   return 0;
}
```
   
   
## 6번문제
---
![[스크린샷 2024-01-14 141113.png]]
> [!failure] 틀림
> 1. DP : 각 index에서 2쌍씩 3개를 골랐을 때 최댓값을 계산하려고 했지만 마지막을 포함한 3개를 골라야되는데 이전 dp테이블은 2개만 골라져있어야 함
> 2. Brute force : 가장 큰 수를 골랐을 때 이 수의 왼쪽 또는 오른쪽이 같은 숫자라면 어떤 숫자를 골라야 될지 결정할 수 없음
```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(vector<int>& A);

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	vector<int> A = { 1, 5, 3, 2, 6, 6, 10, 4, 7, 2, 1 };
	int a = solution(A);
	cout << a;
}

int d[100005];
int solution(vector<int>& A)
{
	int n = A.size();
	d[2] = A[0] + A[1];
	d[3] = max(d[2], A[1] + A[2]);
	d[4] = A[0] + A[1] + A[2] + A[3];
	d[5] = max(d[4], A[4] + A[3] + d[3]);
	d[6] = A[0] + A[1] + A[2] + A[3] + A[4] + A[5];

	for (int i = 7; i <= A.size(); i++)
		d[i] = max(d[i - 1], A[i - 1] + A[i - 2] + d[i - 2]);

	return d[A.size()];
}

/*
Example test:   [2, 3, 5, 2, 3, 4, 6, 4, 1]
WRONG ANSWER (got 0 expected 25)

Example test:   [1, 5, 3, 2, 6, 6, 10, 4, 7, 2, 1]
WRONG ANSWER (got 0 expected 35)

Example test:   [1, 2, 3, 3, 2]
WRONG ANSWER (got 11 expected 10)

Example test:   [5, 10, 3]
WRONG ANSWER (got 18 expected 15)
*/
```






