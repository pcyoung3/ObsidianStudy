---
Index:
  - "[[6. ConfidentialIndex]]"
tags:
  - Study
  - Confidential
---
   
## 1. 1번문제
---
![[스크린샷 2024-02-16 145226.png]]
![[스크린샷 2024-02-16 145241.png]]
### 예시입력1
```
20
111*213*22*3*132**12
4
3 8
10 18
0 11
4 9
```
### 예시출력1
```
6
9
10
0
```

### 예시입력2
```
300
323*3*22*113**3221*32*3*323323132*3*1**211122*311*11121**32*223313213*1133*23221322112212*12*1*2*3112*21122**2221112321123*221*13***12**32***31***231312213133*33312322*1*212*12122**3*1*112*12133332322111****1*331312*13211*2331113222*2*1111111*22311*1233122*3*13212*1121*213321**1*32121*33**3**2*11*12
20
53 166
218 238
92 136
59 235
12 103
23 220
0 255
187 221
71 215
89 231
177 191
199 284
90 237
126 133
170 277
71 133
177 229
205 282
47 247
24 269
```

### 예시출력3
```
149
22
53
257
134
278
352
50
199
181
8
104
200
4
147
79
58
104
275
333
```

## 풀이
> [!tip] 구현 및 DP 문제(데이터를 미리 저장한 후 꺼내옴)
```cpp
#include "bits/stdc++.h"
using namespace std;

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n, q;
	string input;
	cin >> n >> input >> q;

	vector<tuple<int, int, int>> vt;
	vt.reserve(input.length());

	int idx = 0, cache = 0;
	bool isFound = false;
	for (int i = 0; i < input.length(); ++i)
	{
		const char& c = input[i];
		if (c == '*')
		{
			isFound = true;
			vt.push_back({ idx ,i ,cache });
			cache = 0;
			idx = i + 1;
			continue;
		}
		else if (!isFound)
			continue;

		cache += c - '0';
	}

	for (int i = 0; i < q; ++i)
	{
		int x, y, ans = 0;
		cin >> x >> y;

		for (int j = 0; j < vt.size(); j++)
		{
			int st, en, val;
			tie(st, en, val) = vt[j];
			if (x < st && y >= en)
				ans += val;
		}

		cout << ans << "\n";
	}

	return 0;
}
```
   
   
## 2. 2번문제
---
![[스크린샷 2024-02-16 145253.png]]
![[스크린샷 2024-02-16 145307.png]]

### 예제입력1
```
6 4
1 2 3 4 5 6
```
### 예제출력1
```
8
```

### 예제입력2
```
2 10
2 5
```
### 예제출력2
```
2
```

### 예제입력3
```
1 10
3
```
### 예제출력3
```
0
```
## 풀이
> [!tip] 백트레킹 문제
```cpp
#include "bits/stdc++.h"
using namespace std;

int m, n, ans;
vector<int> a;

void BackTracking(int idx, int sum)
{
	if (sum > n)
		return;

	if (sum == n)
	{
		ans++;
		return;
	}

	int temp;
	for (int i = 0; i < a.size(); i++)
	{
		temp = sum + a[i];
		if (temp > n)
			break;
		if (temp == n)
		{
			ans++;
			return;
		}

		BackTracking(i, temp);
	}

}

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	a.reserve(35);

	cin >> m >> n;
	for (int i = 0; i < m; i++)
	{
		int temp;
		cin >> temp;
		a.push_back(temp);
	}

	BackTracking(0, 0);
	cout << ans;

	return 0;
}
```
   
   
## 3. 3번문제
---
![[스크린샷 2024-02-16 145325.png]]
![[스크린샷 2024-02-16 145335.png]]

### 예제입력1
```
7
roga 1 1
rase 0 1
poru 0 1
gipa 0 1
dego 3 0
bego 3 0
nego 3 0
```
### 예제출력1
```
tego
```

### 예제입력2
```
3
nupa 1 0
bera 1 2
roba 3 0
```
### 예제출력2
```
riba
```

### 풀이
> [!tip] 완전탐색 문제
```cpp
#include "bits/stdc++.h"
using namespace std;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	char first[8] = { 'b', 'd', 'g', 'n', 'p', 'r', 's', 't' };
	char second[5] = { 'a', 'e', 'i', 'o', 'u' };

	list<string> v;

	for (int i = 0; i < 5; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				for (int l = 0; l < 8; l++)
				{
					if (second[i] == second[j] || first[k] == first[l])
						continue;

					string temp;
					temp.push_back(first[k]);
					temp.push_back(second[i]);
					temp.push_back(first[l]);
					temp.push_back(second[j]);

					v.push_back(temp);
				}
			}
		}
	}

	int n;
	cin >> n;
	while (n--)
	{
		string name;
		int AllMatch, partitionMatch;

		cin >> name >> AllMatch >> partitionMatch;


		list<string>::iterator iter;
		for (iter = v.begin(); iter != v.end();)
		{
			int AllMatchCnt = 0;
			int partitionMatchCnt = 0;

			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
				{
					if (x == y && (*iter)[y] == name[x])
						AllMatchCnt++;
					if (x != y && (*iter)[y] == name[x])
						partitionMatchCnt++;
				}

			if (AllMatch != AllMatchCnt || partitionMatch != partitionMatchCnt)
				iter = v.erase(iter);
			else
				iter++;
		}
	}

	if (v.size() == 1)
		cout << v.front();
	else
		cout << 'X';
}
```

## 다른풀이(확인X)
```cpp
#include <bits/stdc++.h>
using namespace std;

static char set13[] = { 'b', 'd', 'g', 'n', 'p', 'r', 's', 't' };
static char set24[] = { 'a', 'e', 'i', 'o', 'u' };

struct Word
{
	char cs[4];
	Word() {}
	Word(char a, char b, char c, char d)
	{
		cs[0] = a;
		cs[1] = b;
		cs[2] = c;
		cs[3] = d;
	}
};

int main(void)
{
	int n;
	cin >> n;
	vector<Word> candidates[2];
	int index = 0;
	for (int i = 0; i < 8; ++i)
		for (int j = 0; j < 5; ++j)
			for (int k = 0; k < 8; ++k)
				for (int l = 0; l < 5; ++l)
				{
					if (i == k || j == l) continue;
					candidates[0].emplace_back(set13[i], set24[j], set13[k], set24[l]);
				}

	for (int i = 0; i < n; ++i)
	{
		string name;
		int a, b;
		cin >> name >> a >> b;

		auto& candidate = candidates[index % 2];
		auto& target = candidates[(++index) % 2];
		target.clear();
		for (const auto& c : candidate)
		{
			int aa = 0, bb = 0;
			for (int ci = 0; ci < 4; ++ci)
				for (int cj = 0; cj < 4; ++cj)
				{
					if (name[ci] == c.cs[cj])
					{
						if (ci == cj) ++aa;
						else ++bb;
					}
				}
			if (a == aa && b == bb)
			{
				target.push_back(c);
			}
		}
	}

	const auto& c = candidates[index % 2];
	if (c.size() == 1)
	{
		const auto& cs = c[0].cs;
		cout << cs[0] << cs[1] << cs[2] << cs[3] << endl;
	}
	else
		cout << "x" << endl;

	return 0;
}
```
   
   
## 4. 4번문제
---
![[스크린샷 2024-02-16 145355.png]]
![[스크린샷 2024-02-16 145405.png]]
### 예시입력1
```
10 3
21 88
23 75
97 35
2 8
67 9
64 75
65 71
70 98
9 71
60 35
```
### 예시출력1
```
12
```
### 예시입력2
```
10 3
554 664
664 799
713 538
171 186
538 557
820 171
53 557
97 719
799 222
538 179
```

### 예시출력2
```
5
```
   
## 풀이
> [!tip] hash 문제
> vector로 보관시키고 map에 index까지 저장시키고 탐색부분을 전부 담당시킴
```cpp
#include "bits/stdc++.h"
using namespace std;

vector<vector<int>> holeGroups;
unordered_map<int, int> stars;

void AddWarmholeGroup(const int& start, const int& end);
void MergeWarmholeGroup(const int& startIndex, const int& endIndex);
void AddWarmholeToGroup(const int& index, const int& id);
int main(void)
{
	int wn, n;   //warmhole number, number
	cin >> wn >> n;
	holeGroups.reserve(wn);

	for (int i = 0; i < wn; i++)
	{
		int start, end;
		cin >> start >> end;

		auto startIter = stars.find(start);
		auto endIter = stars.find(end);
		auto starEnd = stars.end();
		bool isStartNew = (startIter == starEnd);
		bool isEndNew = (endIter == starEnd);

		if (isStartNew && isEndNew)
			AddWarmholeGroup(start, end);
		else if (!isStartNew && !isEndNew)
			MergeWarmholeGroup(startIter->second, endIter->second);
		else if (isStartNew)
			AddWarmholeToGroup(endIter->second, start);
		else if (isEndNew)
			AddWarmholeToGroup(startIter->second, end);
	}

	int ans = 0;
	for (auto&& group : holeGroups)
	{
		int size = group.size();
		if (size <= n)
			ans += size;
	}
	cout << ans;

	return 0;
}

void AddWarmholeGroup(const int& start, const int& end)
{
	int index = holeGroups.size();
	stars.emplace(start, index);
	stars.emplace(end, index);
	holeGroups.emplace_back(vector<int>{start, end});
}

void MergeWarmholeGroup(const int& startIndex, const int& endIndex)
{
	if (startIndex == endIndex)
		return;

	vector<int>& startGroup = holeGroups[startIndex];
	vector<int>& endGroup = holeGroups[endIndex];
	for (int s : endGroup)
	{
		startGroup.emplace_back(s);
		stars[s] = startIndex;
	}
	endGroup.clear();
}

void AddWarmholeToGroup(const int& index, const int& id)
{
	stars.emplace(id, index);
	holeGroups[index].push_back(id);
}
```

## 틀린풀이
> [!bug] 시간복잡도에서 걸림 -> 탐색 중 일부분을 vector를 사용해서 문제
```cpp
#include <bits/stdc++.h>
#include <unordered_set>

using namespace std;

vector<unordered_set<unsigned int>> vs;
int wn, n;    //warmhole number, number

void IsMatchIdx(const int st, const int en, int& a, int& b);
void AddWarmholeGroup(const int st, const int en);
void MergeWarmholeGroup(const int source, const int dest);
void AddWarmholeToGroup(const int idx, const int id);

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> wn >> n;
    for (int i = 0; i < wn; i++)
    {
        int st, en;
        cin >> st >> en;

        int matchIdx[2] = { -1, -1 };
        IsMatchIdx(st, en, matchIdx[0], matchIdx[1]);

        if (matchIdx[0] == -1 && matchIdx[1] == -1)
            AddWarmholeGroup(st, en);
        else if (matchIdx[0] != -1 && matchIdx[1] != -1)
            MergeWarmholeGroup(matchIdx[0], matchIdx[1]);
        else if(matchIdx[0] != -1)
            AddWarmholeToGroup(matchIdx[0], en);
        else
            AddWarmholeToGroup(matchIdx[1], st);
    }

    int ans = 0;
    for (int i = 0; i < vs.size(); i++)
    {
        if (vs[i].size() <= n)
            ans += vs[i].size();
    }
    cout << ans;

    return 0;
}

void IsMatchIdx(const int st, const int en, int& a, int& b)
{
    for (int i = 0; i < vs.size(); i++)
    {
        const auto& stIter = vs[i].find(st);
        const auto& enIter = vs[i].find(en);

        if (stIter != vs[i].end())
            a = i;
        if (enIter != vs[i].end())
            b = i;
    }
}

void AddWarmholeGroup(const int st, const int en)
{
    unordered_set<unsigned int> s;
    s.insert(st);
    s.insert(en);
    vs.push_back(s);
}

void MergeWarmholeGroup(const int source, const int dest)
{
    if (source == dest)
        return;

    for (auto num : vs[source])
        vs[dest].insert(num);

    vs[source].clear();
    vs.erase(vs.begin() + source);
}

void AddWarmholeToGroup(const int idx, const int id)
{
    vs[idx].insert(id);
}
```
   
## 5. 5번문제
---
![[스크린샷 2024-02-16 145419.png]]
![[스크린샷 2024-02-16 145425.png]]

### 예시입력1
```
10
abcd
abcde
sdkfkkoxcc
dkfuds
kdgugs
dkfdu
dsf
dkjfgusdgg
dkdkfdufd
kkoxcc
```
### 예시출력1
```
abcde
dkdkfdufd
```

### 예시입력2
```
50
ecv
pzy
vi
mj
jg
dxd
lr
imo
iz
dnz
gy
os
nif
yh
guc
dd
vt
huh
vxw
hmx
ob
bo
yc
ek
bvi
mn
sb
qs
jr
yp
rd
xse
gzd
ngg
ns
su
gu
vn
pw
wek
xi
hyb
yn
uy
dj
sn
vw
nf
ig
hv
```
### 예시출력2
```
bvi
wek
```

## 틀린풀이
> [!bug]  시간복잡도
```cpp
#include "bits/stdc++.h"
using namespace std;

bool kmp(string str1, string str2);
vector<int> failFunc(string str2);

int main()
{
	int n;
	cin >> n;

	vector<string> strArr[10000];

	while (n--)
	{
		string str;
		cin >> str;

		for (int i = 1; i <= str.length(); i++)
		{
			if (!strArr[i].empty())
			{
				bool complete = false;

				for (string s : strArr[i])
				{
					if (kmp(str, s))
					{
						complete = true;
						cout << str << '\n';
						break;
					}
				}
				if (complete)
					break;
			}
		}
		strArr[str.length()].push_back(str);
	}

	return 0;
}

bool kmp(string str1, string str2)
{
	vector<int> pi = failFunc(str2);

	for (int i = 0, j = 0; i < str1.length(); i++)
	{
		while (j > 0 && str1[i] != str2[j])
			j = pi[j - 1];

		if (str1[i] == str2[j])
		{
			if (j == pi.size() - 1)
				return true;
			else
				j++;
		}
	}

	return false;
}

vector<int> failFunc(string str)
{
	vector<int> pi(str.length());

	for (int i = 1, j = 0; i < str.length(); i++)
	{
		while (j > 0 && str[i] != str[j])
			j = pi[j - 1];

		if (str[i] == str[j])
			pi[i] = ++j;
	}

	return pi;
}
```

## 틀린풀이
> [!bug]  kmp - 예외처리 안됨, 시간복잡도
```cpp
#include <bits/stdc++.h>

using namespace std;

int kmp(const string& allText, const string& searchText);
vector<int> failFunc(string str2);

string allText;
vector<string> strContrainer;
vector<int> idxContatiner;

int main()
{
	int n;
	cin >> n;

	int order = 0;
	strContrainer.reserve(10000);
	idxContatiner.reserve(1000000);
	for (int i = 0; i < n; i++)
	{
		string str;
		cin >> str;
		allText += str;

		strContrainer.push_back(str);
		int len = str.length();
		for (int j = order; j < order + len; j++)
			idxContatiner.push_back(i);
		order += len;
	}

	int idx = 0;
	for (int i = 0; i < n; i++)
	{
		idx += strContrainer[i].length();
		string str = allText.substr(idx);
		int location = kmp(str, strContrainer[i]);
		if (location != -1)
		{
			location += idx;
			cout << strContrainer[idxContatiner[location]] << "\n";
		}
	}

	return 0;
}

int kmp(const string& allText, const string& searchText)
{
	vector<int> pi = failFunc(searchText);

	for (int i = 0, j = 0; i < allText.length(); i++)
	{
		while (j > 0 && allText[i] != searchText[j])
			j = pi[j - 1];

		if (allText[i] == searchText[j])
		{
			if (j == pi.size() - 1)
				return i;
			else
				j++;
		}
	}

	return -1;
}

vector<int> failFunc(string str)
{
	vector<int> pi(str.length());

	for (int i = 1, j = 0; i < str.length(); i++)
	{
		while (j > 0 && str[i] != str[j])
			j = pi[j - 1];

		if (str[i] == str[j])
			pi[i] = ++j;
	}

	return pi;
}
```

## 틀린풀이
> [!bug]  아호코라식 - 시간복잡도
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> failFunc(const string& str) 
{
	int m = str.size();
	vector<int> pi(m, 0);

	for (int i = 1, j = 0; i < m; i++) 
	{
		while (j > 0 && str[i] != str[j])
			j = pi[j - 1];

		if (str[i] == str[j])
			pi[i] = ++j;
	}
	return pi;
}

bool kmp(const string& str1, const string& pattern, const vector<int>& pi) 
{
	for (int i = 0, j = 0; i < str1.size(); i++) 
	{
		while (j > 0 && str1[i] != pattern[j])
			j = pi[j - 1];

		if (str1[i] == pattern[j])
		{
			if (j == pattern.size() - 1)
				return true;
			else
				j++;
		}
	}
	return false;
}

int main() 
{
	int n;
	cin >> n;

	vector<string> patterns(n);
	unordered_map<string, vector<int>> piCache; // 실패 함수 캐싱

	for (int i = 0; i < n; ++i)
		cin >> patterns[i];

	// 모든 패턴에 대해 실패 함수를 미리 계산하고 캐싱
	for (const auto& pattern : patterns)
		piCache[pattern] = failFunc(pattern);

	for (int i = 0; i < n; ++i) 
	{
		bool found = false;
		for (int j = 0; j < n; ++j) 
		{
			if (i != j && kmp(patterns[j], patterns[i], piCache[patterns[i]])) 
			{
				found = true;
				break;
			}
		}
		if (found)
			cout << patterns[i] << '\n';
	}

	return 0;
}
```