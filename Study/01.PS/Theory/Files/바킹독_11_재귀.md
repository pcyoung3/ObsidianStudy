# Index : [[PSIndex]]
## Tag : #Study #PS
---

> [!note] 하나의 함수에서 자기자신을 다시 호출해서 작업을 수행하는 알고리즘

## 1. 수학적 귀납법
---
재귀를 이해할 때 절차적으로 이해하려 하면 안되고 수학적 귀납법을 기초로 이해해야 한다.

| 절차지향적 사고                      | 귀납적사고 |
| :------------------------------------: | :----------: |
| ![[Pasted image 20230609144628.png]] | ![[Pasted image 20230609144635.png]]           |

> [!success] 귀납적 사고
> 1. func(1)이 참임을 증명
> 2. func(k)이 참이라고 가정하고 func(k+1)이 참임을 증명
> -> 해당 명제는 n에 대해서 참

## 2. 재귀의 형태
---
### 2-1. 함수의 정의
return 값과 인자값이 어떻게 구성될지 정의
   
### 2-2. Base Condition
재귀를 빠져나갈 조건
   
### 2-3. 재귀 식
자기자신을 어떤 순서로 반복할 것인지 작성
   
   
## 3. 재귀에 대한 정보
---
![[Pasted image 20230609145513.png]]
![[Pasted image 20230609145516.png]]
![[Pasted image 20230609145522.png]]
   
   
## 4. 연습문제 1629
---
## 문제
https://www.acmicpc.net/problem/1629

자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.

## 출력

첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.

## 예제 입력 1 복사

10 11 12

## 예제 출력 1 복사

4

### 4-1. 정답코드
---
> [!question] 미리 알아야 할 개념
> 1\. 지수법칙 
> ![[Pasted image 20230609164904.png|300]]
> 
> 2\. 모듈러 성질 중 분배법칙
> ![[Pasted image 20230609164956.png]]

> [!question] 구현 상 알아야 하는 부분
> ![[KakaoTalk_20230609_170456147.jpg]]

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll pow(ll a, ll b, ll m)
{
    if (b == 1) //Base Condition 탈출구문
        return a % m;

    //분할정복
    ll val = pow(a, b / 2, m);
    val = val * val % m;    //모듈러 성질
    if (b % 2 == 0) //짝수, 홀수 분할
        return val;
    return val * a % m;
}

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    ll a, b, c;
    cin >> a >> b >> c;
    cout << pow(a, b, c);
}
```
   
   
## 5. 연습문제 11729
---
## 문제
https://www.acmicpc.net/problem/11729

세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

1. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
2. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.

아래 그림은 원판이 5개인 경우의 예시이다.

![[hanoi.png]]

## 입력

첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.

## 출력

첫째 줄에 옮긴 횟수 K를 출력한다.

두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.

## 예제 입력 1 복사

3

## 예제 출력 1 복사
```
7
1 3
1 2
3 2
1 3
2 1
2 3
1 3
```
   
   
### 5-1. 정답코드
---
> [!question] 하노이 탑이 옮겨지는 과정

| n개의 원판을 옮길 때                 | n-1개의 원판을 기둥 2로 옮김 |
| :------------------------------------: | :----------------------------: |
| ![[Pasted image 20230610190738.png]] | ![[Pasted image 20230610190741.png]]                             |

| n번째 원판을 기둥3으로 옮김          | n-1개의 원판을 기둥 3으로 옮김 |
| ------------------------------------ | ------------------------------ |
| ![[Pasted image 20230610190746.png]] | ![[Pasted image 20230610190750.png]]                               |

> [!danger] 절대 절차적인 접근을 해서는 안됨
> 절차적 접근을 하는 순간 끝이 없다. 수학적 귀납법으로 접근해야 한다.
> 
> 1\.  원판 1개를 내가 원하는 곳으로 옮길 수 있다.
> 
> 2\. n번째 원판을 옮기기 위해서는 n-1번째 원판을 옮겨야 함.
> 거꾸로 말하면 n-1번째 원판을 옮길 수 있다면 n번째 원판을 옮길 수 있다.
> -> 원판이 k개일 때 옮길 수 있다고 가정하면 k+1개일 때에도 옮길 수 있다.
> 
> 2가지로 귀납법이 성립하고 재귀로 접근할 수 있다

> [!success] 함수 구조
> ![[Pasted image 20230610193137.png]]
> 이해가 안가겠지만 귀납적으로 이해를 해야한다
> 또한, 재귀함수는 맞게 호출된다고 믿고 써야 한다. 이게 진짜 맞는지 검증을 하려고 하면(절차적인 검증) 답이 없어진다
 
```cpp
#include <bits/stdc++.h>
using namespace std;

void hanoi(int a, int b, int n)
{
    //n이 1개일때는 그냥 원판을 옮길 수 있음
    if (n == 1)
    {
        cout << a << " " << b << '\n';
        return;
    }

    //6은 기둥 1+2+3 의 합
    //1. n-1개의 원판을 a기둥에서 b가 아닌 다른 기둥으로 옮김
    hanoi(a, 6 - a - b, n - 1);
    //2. 마지막 n번째 원판 1개를 a기둥에서 b기둥으로 옮김
    hanoi(a, b, 1);
    //3. n-1개의 원판을 a와b가 아닌 기둥에서 b 기둥으로 옮김
    hanoi(6 - a - b, b, n - 1);
}

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;

    //초항이 1이고 2A+1인 수열의 일반식 -> 보통은 몰라도 됨
    //(1<<k) -1 이라고 해도 같다 2^k 승
    long long result = pow(2, n) - 1;
    cout << result << '\n';
    hanoi(1, 3, n);
}
```
   
   
## 6. 연습문제 1074번
---
## 문제
https://www.acmicpc.net/problem/1074

한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.


![[z_1.png|200]]
N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

다음 예는 22 × 22 크기의 배열을 방문한 순서이다.
![[z_2.png|400]]

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.

다음은 N=3일 때의 예이다.
![[z_3.png|800]]

## 입력

첫째 줄에 정수 N, r, c가 주어진다.

## 출력

r행 c열을 몇 번째로 방문했는지 출력한다.

## 제한

- 1 ≤ N ≤ 15
- 0 ≤ r, c < 2N

## 예제 입력 1 복사

2 3 1

## 예제 출력 1 복사

11

## 예제 입력 2 복사

3 7 7

## 예제 출력 2 복사

63

## 예제 입력 3 복사

1 0 0

## 예제 출력 3 복사

0

## 예제 입력 4 복사

4 7 7

## 예제 출력 4 복사

63

## 예제 입력 5 복사

10 511 511

## 예제 출력 5 복사

262143

## 예제 입력 6 복사

10 512 512

## 예제 출력 6 복사

786432
   
   
### 6-1. 정답코드
---
> [!question] n이 k일 때의 결과를 가지고 k+1일 때에 써먹을 수 있다.
> k가 참이라고 가정할 때 k+1도 참
> : 수학적 귀납법
> 
> 즉, 재귀를 쓰는 문제 

```cpp
#include <bits/stdc++.h>
using namespace std;

int func(int n, int r, int c) {
    //Base condition -> 지금까지 더한 half 값이 결과물
    if (n == 0) return 0;

    //현재 사각형의 절반의 크기
    int half = 1 << (n - 1);

    //1  2
    //3  4 사각형일 때
    //r c 모두 사각형 절반보다 작다면 사각형은 1번
    if (r < half && c < half) return func(n - 1, r, c);

    //c가 절반보다 크다면 인덱스로 1번 사각형(half * half)을 더해주고
    //2번 사각형만 보면 되니 나머지 사각형은 볼 필요가 없으므로 c-half를 해줌
    //이럴경우 r와 c이 점점 작은 사각형으로 맞춰들어감
    if (r < half && c >= half) return half * half + func(n - 1, r, c - half);

    //3번 사각형
    if (r >= half && c < half) return 2 * half * half + func(n - 1, r - half, c);

    //4번 사각형
    return 3 * half * half + func(n - 1, r - half, c - half);
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, r, c;
    cin >> n >> r >> c;
    cout << func(n, r, c);
}
```

   
### 6-3. 다른 코드
```cpp
#include <iostream>
using namespace std;

int n, r, c;
int ans;

void Z(int y, int x, int size)
{
    //(r, c) 칸을 찾음 -> Base Condition 1
    if (y == r && x == c)
    {
        cout << ans << '\n';
        return;
    }

    //r,c가 현재 사각형에 존재한다면 -> Base Condition 2
    if (r < y + size && r >= y && c < x + size && c >= x)
    {
        //1번 사각형 탐색
        Z(y, x, size / 2);
        //2번 사각형 탐색
        Z(y, x + size / 2, size / 2);
        //3번 사각형 탐색
        Z(y + size / 2, x, size / 2);
        //4번 사각형 탐색
        Z(y + size / 2, x + size / 2, size / 2);
    }
    else
    {
        //차례대로 1번 2번 3번 4번 사각형을 본 뒤
        //앞 사각형에 (r, c)가 없으므로 앞 사각형만큼 더해준다
        //프로그램이 종료될 때 정답 이상의 ans가 나올 수 있지만 출력은 되지 않음
        ans += size * size;
    }
}
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> r >> c;
    Z(0, 0, (1 << n));// 2^n 승을 (0, 0) 부터 전위순회
    return 0;
}
```
   
   
## 7. 재귀 관련 어록
---
```
재귀는 현재 상태에서만 생각하고 호출할 재귀는 반드시 잘 돌아간다고 믿고 짜야함. 그느낌을 탁 알게될때가 잇음
미래의 자신이 짜는 코드가 잘 돌아간다고 가정하고 짜는 거임
우리 함수는 할수있다 라는 믿음을 가지고 그냥 박아넣어야함
작은 건 이미 풀렸다고 치는 거임
너무 실제 돌아가는 모습을 신경쓰면 안됨 더 작은 문제를 풀어주는 함수가 있다고 치고 그 함수를 이용해서 전체 문제를 푼다고 생각을 해야 함
재귀의 절차는 원래 이해하는 거 아님
애초에 재귀나 점화식 같은건 머릿속에서 동작 그리는거 아니라고 생각함
반복할 행동 + 종료 조건 이 두개만 확실히하면 백트래킹 짜기 쉬워짐
0일 땐 이걸 리턴해야되고 1일땐 이걸 리턴해야되고 하나씩 결과를 쳐내는 식으로
그냥 끝나는 케이스를 생각하고 쪼개는 방법을 생각하면 됨 영원히 루프를 돌지 않는 형태로 함수를 잘 만들었으면 잘 작동할거임
```